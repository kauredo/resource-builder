#!/usr/bin/env node
/* eslint-disable no-console */
import fs from "node:fs";
import path from "node:path";
import os from "node:os";
import { execSync } from "node:child_process";

const ROOT = process.cwd();
const PUBLIC_FONTS_DIR = path.join(ROOT, "public", "fonts");
const GENERATED_CONFIG_PATH = path.join(
  ROOT,
  "src",
  "lib",
  "pdf-fonts.generated.ts",
);

const FAMILIES = [
  { name: "Nunito", dir: "nunito" },
  { name: "Quicksand", dir: "quicksand" },
  { name: "Poppins", dir: "poppins" },
  { name: "Merriweather", dir: "merriweather" },
  { name: "Baloo 2", dir: "baloo2" },
  { name: "Fredoka", dir: "fredoka" },
  { name: "Comfortaa", dir: "comfortaa" },
  { name: "Pacifico", dir: "pacifico" },
  { name: "Open Sans", dir: "opensans" },
  { name: "Lato", dir: "lato" },
  { name: "Inter", dir: "inter" },
  { name: "Source Sans Pro", dir: "sourcesanspro" },
  { name: "Rubik", dir: "rubik" },
  { name: "Roboto", dir: "roboto" },
  { name: "Nunito Sans", dir: "nunitosans" },
  { name: "Work Sans", dir: "worksans" },
];

const WEIGHT_MAP = new Map([
  ["Thin", 100],
  ["ExtraLight", 200],
  ["Light", 300],
  ["Regular", 400],
  ["Medium", 500],
  ["SemiBold", 600],
  ["Bold", 700],
  ["ExtraBold", 800],
  ["Black", 900],
]);

const ALLOWED_WEIGHTS = new Set([400, 700]);

function run(cmd, cwd) {
  execSync(cmd, { stdio: "inherit", cwd });
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function resolveFamilyPath(repoDir, dirName) {
  const candidates = [
    path.join(repoDir, "ofl", dirName),
    path.join(repoDir, "apache", dirName),
    path.join(repoDir, "ufl", dirName),
  ];
  return candidates.find((p) => fs.existsSync(p));
}

function parseFontMeta(filename) {
  const base = path.basename(filename, ".ttf");
  const isItalic = base.toLowerCase().includes("italic");
  const style = isItalic ? "italic" : "normal";

  let weight = 400;
  for (const [label, value] of WEIGHT_MAP.entries()) {
    if (base.includes(label)) {
      weight = value;
      break;
    }
  }
  return { weight, style };
}

function writeGeneratedConfig(config) {
  const content = `/* This file is auto-generated by scripts/fetch-pdf-fonts.mjs */\n` +
    `export const GENERATED_PDF_FONT_CONFIG = ${JSON.stringify(config, null, 2)} as const;\n`;
  fs.writeFileSync(GENERATED_CONFIG_PATH, content);
}

function main() {
  ensureDir(PUBLIC_FONTS_DIR);

  const repoDir = path.join(os.tmpdir(), "google-fonts");
  if (!fs.existsSync(repoDir)) {
    run(
      "git clone --depth 1 --filter=blob:none --sparse https://github.com/google/fonts.git " +
        repoDir,
      ROOT,
    );
  } else {
    run("git fetch --depth 1 origin main", repoDir);
    run("git checkout main", repoDir);
  }

  const sparsePaths = [];
  for (const family of FAMILIES) {
    sparsePaths.push(`ofl/${family.dir}`);
    sparsePaths.push(`apache/${family.dir}`);
    sparsePaths.push(`ufl/${family.dir}`);
  }
  run(`git sparse-checkout set ${sparsePaths.join(" ")}`, repoDir);

  const generatedConfig = {};

  for (const family of FAMILIES) {
    const familyPath = resolveFamilyPath(repoDir, family.dir);
    if (!familyPath) {
      console.warn(`Skipping ${family.name}: directory not found`);
      continue;
    }

    const files = fs
      .readdirSync(familyPath)
      .filter((file) => file.toLowerCase().endsWith(".ttf"))
      .filter((file) => {
        const { weight, style } = parseFontMeta(file);
        return style === "normal" && ALLOWED_WEIGHTS.has(weight);
      });

    if (files.length === 0) {
      console.warn(`Skipping ${family.name}: no .ttf files found`);
      continue;
    }

    const outDir = path.join(PUBLIC_FONTS_DIR, family.dir);
    ensureDir(outDir);

    const fontEntries = [];
    for (const file of files) {
      const srcPath = path.join(familyPath, file);
      const destPath = path.join(outDir, file);
      fs.copyFileSync(srcPath, destPath);

      const { weight, style } = parseFontMeta(file);
      fontEntries.push({
        src: `/fonts/${family.dir}/${file}`,
        fontWeight: weight,
        fontStyle: style,
      });
    }

    generatedConfig[family.name] = {
      family: family.name,
      fonts: fontEntries,
    };
  }

  // Alias: "Fredoka One" should map to Fredoka files if available
  if (generatedConfig.Fredoka) {
    generatedConfig["Fredoka One"] = {
      family: generatedConfig.Fredoka.family,
      fonts: generatedConfig.Fredoka.fonts,
    };
  }

  writeGeneratedConfig(generatedConfig);

  console.log("Done. Generated:", GENERATED_CONFIG_PATH);
  console.log("Fonts copied to:", PUBLIC_FONTS_DIR);
}

main();
